#Variables
var_int = 10 # мы одновременно объявляем переменную и присаиваем ей значение
var_float = 8.4 # пайтон сам понимает тип переменной по формату присваемого значение
var_str = "No"
var_big = var_int * 3.5 # Просто умножаем одно на другое
var_float -=1 # так мы отнимаем: var_float -=1 это то же самое, что var_float = var_float - 1
var_int / var_float # просто делим, т.к. не было задачи присвоить это значение какой-то переменной
var_big / var_float # см выше
var_str = "No" * 2 + "Yes" * 3 # "конкатенация" означает что-то вроде "соединить по цепочке".
# Мы можем использовать математические операторы для дубливарочания или "склеивания" строк.
# * используем для дублирования, поэтому "No" * 2 и "Yes" * 3 , а + используем для склеивания.
print("var_int :", var_int)
print("var_float: ", var_float)
print("var_str:", var_str)
print("var_big:", var_big)

# Strings
# Задание 1
str_eight = "How are you?"
lnth = len(str_eight) # определяем длину строки функцией len() и присваиваем переменной lnth для удобства
print(str_eight, ";", str_eight[0], str_eight[lnth-1], str_eight[2], str_eight[lnth-3], "String length:", lnth)
# если я правильно поняла слово "извлечь" (= определить и напечатать), то принцип выполнения такой
# str_eight[номер_позиции_символа] выбирает нужный нам символ из строки: как помним индексы начинаются с нуля
# номер последнего символа = длина строки - 1, т.к. количество символов считается с 1, а индексы с нуля.
# поэтому у 1-ого символа индекс [0]; у последнего: [длина-1]; у 3-го с начала: [2]; а у 3-го с конца: [длина-3]

# Задание 2
str_ten = "benzodiazepines"
lnth2 = len(str_ten) # определяем длину строки функцией len() и присваиваем переменной lnth2 для удобства
str_center = lnth2 // 2 # нам нужно определить середину строки: делим длину строки на 2, но нам нужно целое
#число, поэтому мы используем //. У нас 15 символов, делим целочисленно на 2 и получаем 7, что и есть № середины.
print(str_ten, "/ String length:", )
print(str_ten[0:8], "/", str_ten[(str_center-1):(str_center+3)], "/", str_ten[3:lnth2:3], "/", str_ten[::-1], "/")
# когда мы задаем подстроку (xfcnm), то последний символ не включается, поэтому 8 символов это str_ten[0:8], а не str_ten[0:7]
# нашла, что имя_строки[начало:конец:чему кратный индекс] выдает только каждый н-ный символ из строки. Начало [3], иначе
# печатает самый первый символ. И "индекс кратный трем" я понимаю как "3, 6, 9 и т.д."
# нашла, что имя_строки[::-1] переворачивает строку. Как работает, не разбиралась.

# Задание 3
str_name = "my name is name"
f = str_name.rfind('name') # этот метод позволяет находить кусок строки, начиная поиск с конца. Возвращает № индекса начала
str_name = str_name[0:f] + "Artiom" # берем нужный кусок строки (т.е. до ненужной подстроки) и прибавляем Artiom
print(str_name)

# Задание 4
test_tring = "Hello world!"
print("index of 'w' is", test_tring.find("w")) # имя_строки.find("символ") находит символ в строке
print("There are", test_tring.count("l"), "letters 'l'.")
print("'Hello' at the beginning:", test_tring.startswith("Hello")) # ищет в начале строки заданную комбинацию
print("'qwe' at the end:", test_tring.startswith("qwe")) # ищет в конце строки заданную комбинацию
# два последних метода возвращают True (нашлось) или False (отсутствует)

# Lists
# Задания 1-4
list_one = [1, 3, 4, 9, 5, 6, 17, 16, 2, 7]
list_two = [21, 35, 68, 8, 44, 96, 13, 71, 64, 47]
print("2nd element of the 1st list:", list_one[1]) # позицию узнаем так: название_списка[номер_индекса]
list_two[len(list_two)-1] = 444 # индекс последнего элемента равен длине списка минус 1 => len(list_two) это длина
print("2nd list:", list_two)
list_both = list_one + list_two # опять используем + для объединения списков
print("common list:", list_both)
# Задания 5-6
list_both_new = list_both [0:5] + list_both [(len(list_both)-4):(len(list_both))] # надеюсь, я правильно поняла и можно
# взять любые куски первоначальных списков: поэтому я взяла 5 элементов из начала list_both [0:5] и 4 элемента с конца
# list_both [(len(list_both)-4):(len(list_both))], где (len(list_both)-4) это позиция (длина списка - 4), а
# (len(list_both)) это позиция (конец списка)
print(list_both_new)
list_both_new.extend([8, 153]) # имя_строки.append добавляет в конец только один элемент, а имя_строки.extend добавляет
# много элементов, только их обязательно записать в двух типах скобок ([а, тут, через, запятую])
# list_both_new = list_both_new + [8, 153] # можно и так добавить элементы
print("final list:", list_both_new)
# Задания 7-8
a = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
b = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]
a = set(a) # преобразуем список в множество, т.к. множества мы можем объединять нужным нам способом
b = set(b) # аналогично
c = a.union(b) # функция имя_множества.union(имя_второго_множества) объединяет два множества без повтора элементов
print("united list:", c)
d = [1, 2, 3, 4, 3, 2, 5, 1, 4, 6, 7, 1, 8, 2, 3]
d = set(d) # преобразуем список в множество, и так автоматически уберуться все повторяющиеся элементы
d = list(d) # преобразуем множество обратно в список
print("list with unique element:", d)

# Логические операции
d = 6
e = 18
print("__and__")
print(d < e and (e - d) > 0)
print(d < e and d > 0)
print(d > e and (e * d) == 0)
print(d == e and (e - d) > 0)
print("__or__")
print(d < e or e > 0)
print(d < e or d != 0)
print(d > e or e <= 0)
print(d == e or (e - d) < 0)
str_logic = "Python"
print("__and__or___string")
print(len(str_logic) < 7 and str_logic[0] == "P") # напомню len() метод для узнавания длины строки
print(str_logic[0] == str_logic[len(str_logic)-1] or str_logic == 7) # а здесь сравниваем символы первый и последний

# Dictionaries
school = {"1а": 32, "1б": 27, "2б": 30, "3и": 29, "5к": 26, "6а": 31, "7в": 25, "8д": 28, "9г": 24, "10в": 22}
print("School:", school)
print("In the group '5к' there are", school.get("5к"), "pupils.")
school["1а"] = 31 # изменили кол-во учеников
school["7в"] = 27 # изменили кол-во учеников
school["9г"] = 28 # изменили кол-во учеников
school["2ж"] = 27 # добавили класс
school["6г"] = 26 # добавили класс
school.pop("5к") # убрали один класс
print("Changes at school:", school)

# Преобразование типов
# Задания 1-3
str_a = "Robin Singh"
str_a = str_a.split() # функция имя_строки.split() делить строку на слова и заносит в список. Мы в скобках ничего
# не указываем, потому что делим на основании пробела. Если бы в строке была запятая, то было бы имя_строки.split(",")
str_b = "I love arrays they are my favorite"
str_b = str_b.split()

list_Ivan = ["Ivan", "Ivanou"]
str_Minsk = "Minsk"
str_Belarus = "Belarus"

list_a = ["I", "love", "arrays", "they", "are", "my", "favorite"]
list_a = ' '.join(list_a) # функция join() объединяет список в строку и пишется в формате 'разделитель'.join(имя_списка)
# разделитель (например, пробел или запятая) указывается в одинарных кавычках. Но можно не указывать.

print(str_a)
print(str_b)
print(list_a)
print("Привет,", ' '.join(list_Ivan), "! Добро пожаловать в", str_Minsk, str_Belarus) # здесь для правильного вывода
# списка (без кавычек) пришлось объединить список в строку

# Задание 4
list_ten = ["съешь", "же", "ещё", "этих", "мягких", "французских", "булок", "да", "выпей", "чаю"]
print(list_ten)
list_ten.insert(2, "ты") # добавили на позицию 3, но индекс, как я понимаю, будет 2
list_ten.pop(6) # удалили по индексу
print(list_ten)

# Задание 5
a = {"a": 1, "b": 2, "c": 3}
b = {"c": 3, "d": 4, "e": 5}
ab = a | b # оператор merge (|) позволяет объединять два словаря с помощью одного символа |
# здесь надо переделать, т.к. в задании сложнее условие
print(ab)

# Условия
num_one = 8
if num_one > 0:
    num_one +=1 # здесь мы просто увеличим. Можно было бы 2 раза задать print и else, то тогда это отягощенная логика:
    # а так у нас, если условие выполнится, то число увеличится, и программа пойдет дальше, дойдя до печати. Если же
    # условие не выполняется, то программа сразу пойдет дальше, пропустив шаг с увеличением. Кстати, изначально
    # я сделала с двумя print, но мне не понравилась логика.
print(num_one)

list_three = [5, 89, -4]
i = 0 # задаем счетчик для положительных чисел
for item in list_three: # в переменную item с каждым проходом по циклу будет вноситься элемент списка
    if item > 0: # если значение item больше нуля (нуль, наверное, не включаем), то
        i += 1 #мы счетчик увеличим на 1
print("Positive numbers:", i)

# Задание 3: високосный год. Вероятно, логика немного корявая
year = 700
if (year % 400 != 0) and (year % 100 == 0): # сразу проверяем на годы, что на 100 делятся. Они обязательно дожны делиться
    # без остатка на 400, тогда это високосный. Если условие не выполнилось, то идем делить на 4.
    print (year, "не високосный год")
elif (year % 4 == 0):
    print (year, "високосный год") # если на 4 разделилось без остатка, то високосный. Иначе идет дальше
else:
    print (year, "не високосный год")

# Задание 4
g = 5
days_week = {1: "понедельник", 2: "вторник", 3: "среда", 4: "четверг", 5: "пятница", 6: "суббота", 7: "воскресенье"}
print(days_week)
#print("Today is", days_week[g])